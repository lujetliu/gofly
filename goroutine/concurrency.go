package main

/*
 * 常见的并行编程有多种模型, 主要有多线程, 消息传递等; 理论上来说, 多线程和
 * 基于消息的并发编程等价, 由于多线程并发模型可自然对应到多核处理器, 主流的
 * 操作系统因此都提供了系统级的多线程支持, 因此多线程编程模型逐步被吸纳到主流
 * 的编程语言特性或语言扩展库中; 而主流编程语言对基于消息的并发编程模型支持
 * 较少, Erlang 语言是支持基于消息传递并发编程模型的代表者, 它的并发体中间不
 * 共享内存, go 语言是基于消息并发模型的集大成者, 它将基于 CSP 模型的并发编程
 * 内置到语言中, 通过一个 go 关键字就可以启动一个 Goroutine , 与 Erlang 不同,
 * go 语言的 Goroutine 之间是共享内存的.
 */

/*
 * Goroutine 和系统线程
 * goroutine 是 go 特有的并发体, 是一种轻量级的线程; goroutine 和系统线程实际上
 * 只是一个量的区别, 正是这个量变引发了go语言并发编程的质的飞跃.
 *
 * 每个系统级线程都会有一个固定大小的栈(2MB), 主要保存函数递归调用时的参数和
 * 局部变量; 但固定栈的大小会存在两个问题(不够灵活):
 * - 有的线程(很多)只需要很小的栈空间, 固定的栈大小会造成浪费
 * - 少数需要巨大栈空间的线程又面临栈溢出的风险
 * 所以为了解决以上问题, 要么降低固定的栈大小, 提升空间利用率; 要么增大栈的大小
 * 以运行更深的函数递归调用, 但两者无法兼得.
 * 但一个 goroutine 会以一个很小的栈启动(2KB/4KB/8KB), 当遇到深度递归导致当前
 * 栈空间不足时, goroutine 会根据需要动态的伸缩栈的大小(主流实现中栈的最大值可
 * 达到1GB), 因为启动的代价很小, 所以可以轻易的启动很多个(成千上万)goroutine.
 * TODO: 查看 goroutine 的栈空间, 并跟踪栈空间大小的变化
 *
 *
 * TODO: 系统进程调度原理, 线程调度, goroutine 调度器
 * go 的运行时还包含了自己的调度器, 此调度器可以在n个操作系统上多工调度m个
 * goroutine.
 * 多工: 一个作业系统可以同时执行多个程式的能力.
 * go 调度器的工作原理和内核的调度相似, 但是 go 调度器只关注 go 程序中的
 * goroutine, goroutine 采用的是半抢占式的协作调度, 只有在当前 goroutine 发生
 * 阻塞时才会导致调度; 同时发生在用户态, 调度器会根据具体函数只保存必要的
 * 寄存器, 切换的代价比系统线程低的多; 运行时的一个变量 runtime.GOMAXPROCS 用
 * 于控制当前运行非阻塞 goroutine 的系统线程数.
 *
 * goroutine 相比系统线程的优点: 启动简单, 调度代价低, 极大的促进了并发编程的
 * 发展.
 *
 */

/*
 * CSP模型: TODO: 深入
 * 用于描述两个独立的的并发实体通过共享的通讯 Channel(通道) 进行通信的并发模型,
 * channel 是第一类对象(?), 不关注发送消息的实体而关注发送消息时使用的 Channel
 *
 */
