package main

/* 定制代码生成插件 */

// Protobuf 的 protoc 编译器通过插件机制实现对不同语言的支持, 例如: 如果 protoc
// 命令出现 --xxx_out 格式的参数, protoc 将首先查询是否有内置的 xxx 插件, 如果
// 没有内置的 xxx 插件, 将继续查询当前系统中是否存在以 protoc-gen-xxx 命名的可
// 执行程序, 最终通过查询到的插件生成代码; 对于 go 语言的 protoc-gen-go 插件,
// 里面又实现了一层静态插件系统; 例如, protoc-gen-go 内置了 gRPC 插件, 用户可以
// 通过 --go_out=plugins=grpc 参数生成 gRPC 相关的代码, 否则只会针对 service
// 生成相关代码.

// TODO: protoc-gen-go 源码
// 参考 gRPC 插件的代码, generator.RegisterPlugin() 函数可以注册插件, 插件
// 是一个 generator.Plugin 接口.
// "github.com/golang/protobuf/protoc-gen-go/generator"

// A Plugin provides functionality to add to the output during Go code generation,
// such as to produce RPC stubs.
// type Plugin interface {
// 	// Name identifies the plugin.
// 	Name() string // 插件名字, go语言 protobuf 实现的插件体系, 与 protoc 插件的
//                // 名字无关
// 	// Init is called once after data structures are built but before
// 	// code generation begins.
// 	Init(g *Generator) // 初始化插件, 参数 g 中包含 proto 文件的所有信息
// 	// Generate produces the code generated by the plugin for this file,
// 	// except for the imports, by calling the generator's methods P, In, and Out.
// 	Generate(file *FileDescriptor) // 生成主体代码
// 	// GenerateImports produces the import declarations for this file.
// 	// It is called after Generate.
// 	GenerateImports(file *FileDescriptor) // 生成导入包代码
// }

// 因此可以实现插件为标准库的 rpc 生辰代码 ./netrpcPlugin.go
