package main

import "fmt"

/*
 * 函数, 方法和接口
 *
 * 函数对应操作序列, 是程序的基本组成元素
 * go 中的函数有具名和匿名之分, 具名函数一般对应于包级的函数, 是匿名函数的
 * 一种特例.
 * 当匿名函数引用了外部作用域中的变量时就成了闭包函数, 闭包函数是函数式
 * 编程语言的核心
 *
 * 方法是绑定到一个具体类型的特殊函数, go 中的方法依托于类型, 必须在编译时
 * 静态绑定, 方法是函数的一种
 *
 * TODO: 加深理解方法集, 鸭子面向对象模型
 * 接口定义了方法的集合(方法集), 这些方法依托于运行时的接口对象, 因此接口对
 * 应的方法方法是运行时动态绑定的, go 语言通过隐式接口机制实现了鸭子面向
 * 对象模型
 *
 *
 * go 语言中, 函数支持递归调用(直接或间接?), 递归调用在深度上没有限制, 函数
 * 调用的栈不会出现溢出错误, go 运行时会根据需要动态调整函数栈的大小
 *
 *
 */

// 函数 TODO: 第一类对象?
// 函数是第一类对象, 分为具名函数和匿名函数, 可以将函数保存到变量中
func Add(a, b int) int                         { return a + b } // 具名函数
var Add1 = func(a, b int) int { return a + b } // 匿名函数

// 参数和返回值都是以传值的方式和被调用者交换数据, 在语法上, 函数还支持
// 可变数量的参数, 可变数量的参数必须是最后传入的参数, 其实是一个切片类型
// 的参数

func output() {
	// 当可变参数是一个空接口类型时, 调用者是否解包(TODO)可变参数会导致
	// 不同的结果
	var a = []interface{}{123, "abc"}
	Print(a...) // 123 abc
	Print(a)    // [123 abc]
}

func Print(a ...interface{}) {
	fmt.Println(a...)
}

// 可以给函数的返回值命名
// 如果返回值命名, 可以通过名字修改返回值, 也可以通过 defer 语句在 return
// 语句之后修改返回值(可以在函数内部做一些返回前的检查, 装饰器?钩子?)
func Inc() (v int) {
	defer func() { v++ }()
	return 42
}

/*
 * defer 语句延迟执行了一个匿名函数, 此匿名函数捕获了外部函数的局部变量 v,
 * 这中匿名函数称为闭包, 闭包对捕获的外部变量是以引用方式访问, 而非传值方式,
 * 传值方式即复制副本
 */

// 闭包的以引用方式访问外部变量的行为可能会导致一些隐含的问题:
func main() {
	for i := 0; i < 3; i++ {
		// i := i // 在循环体内定义局部变量 i
		// 注意这里的2个 i 有不同的作用域, 后者属于整个 for 循环体, 而前者
		// 的作用域为本次循环, 固不存在重复定义变量的报错
		// defer func(i int) { fmt.Println(i) } (i) // 传值(副本)
		defer func() { fmt.Println(i) }()
		fmt.Printf("loop-%v\n", i)
		// Warning: loop variable i captured by func literal
	}
}

// Output:
// loop-0
// loop-1
// loop-2
// 3
// 3
// 3
// i 是 for 循环体中建立的临时局部变量, 在循环结束后 i 的值为 3
// 在 for 迭代语句中, 所有的 defer 都是在 for 循环完退出前执行, 因为闭包
// 以引用方式访问外部函数的局部变量 i, 所以在最后 3 次 defer 处的匿名函数
// 输出 3; goroutine 同理, 有2种方法解决:
// - 在循环体内定义局部变量(line 67); 这样每次迭代 defer 语句的闭包函数
// 每次捕获的都是不同的变量, 这些变量的值对应迭代时的值
// - defer 立即对调用参数求值(line 70); 在匿名函数中建立临时变量, 以传值的方式
// 传参数(副本)
//

/*
 * 不建议在 for 循环内部使用 defer , 以上只作为示例说明
 */

/*
 * 如果以切片为参数调用函数, 因为在函数内部可以修改传入的切片的元素, 产生
 * 了参数采用了传引用方式的假象; 其实, 任何可通过函数参数修改调用参数的情形,
 * 都是因为函数参数中显式或隐式传入了至指针参数, 函数参数传值的规范确切说是
 * 只针对数据结构中固定的部分传值.
 * 例如字符串或切片对应结构体中的指针和字符串长度结构体传值, 但是并不包含(?)
 * 指针间接指向的内容
 *
 *
 * 切片中的底层数组部分通过隐式指针传递(指针本身是传值的, 但是指针指向的是
 * 同一份数据); 以切片为参数调用函数, 被调用函数可以通过指针修改调用参数切片
 * 中的数据, 切片结构还包含了切片长度和切片容量信息(都是传值的);
 * 如果在被调用函数中修改了切片的 Len 或 Cap 信息, 就无法反映到调用参数的
 * 切片中, 这时通过返回修改后的的切片来更新之前的切片, 这也是内置 append()
 * 必须返回切片的原因.
 *
 */

/* TODO: 堆栈, 动态栈(go高级编程, Page31), cpu高速缓存, 虚拟内存, 页表
 * go 的函数支持递归调用, 递归调用的深度在逻辑上没有限制, 且函数调用的栈
 * 不会出现溢出错误, 因为, go 语言的运行时会根据需要动态调整函数栈的大小;
 * 每个 goroutine 刚启动时只会分配很小的栈(4KB或8KB, 依赖实现), 根据需要
 * 动态调整, 栈最大可以达到 GB 级(依赖具体实现, 32位体系结构为 250MB, 64位)
 * 体系结构为1GB)
 *
 */
