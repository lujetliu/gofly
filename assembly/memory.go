package main

/*
	TODO: 深入理解, 虚拟内存
	内存布局

					-----------------
					|               |栈底      高地址
					|    stack      |           /|\
					|               |            |
					|               |            |
					|               |            |
					|               |            |
					|              \|/栈顶       |
					|---------------|            |
					|               |            |
					|    unused     |            |
					|               |            |
					|               |            |
					|               |            |
					|               |            |
					|               |            |
					|               |            |
					|---------------|            |
					|               |            |
					|    heap       |            |
					|               |            |
					|               |            |
					|---------------|            |
					|               |            |
					|    data       |            |
					|               |            |
					|               |            |
					|---------------|            |
					|               |            |
					|    rodata     |            |
					|               |            |
					|               |            |
					|---------------|            |
					|               |            |
					|    text       |            |
					|               |            |
					|               |            |
					|---------------|            |
						  内存                低地址

	text: 代码段, 用于存储要执行的指令数据, 只读
	rodata: 只读数据段
	data: 数据段, 存放全局的数据
	heap: 堆, 管理动态的数据
	stack: 管理函数调用时相关的数据
	汇编语言重点关注代码段和数据段, 因此提供了 TEXT 和 DATA 命令用于定义
	代码和数据;

	寄存器是cpu最重要的资源, 每个要处理的内存数据原则上需要先放到寄存器中才能
	由cpu处理, 同时寄存器中处理完的结果需要再存入内存, x86 提供以下寄存器:
	FLAGS: 指令寄存器
	IP: 指针指令寄存器

	通用寄存器
	AX, BX, CX, DX, SI, DI, BP, SP, R8-R15

	从x87 开始引入的 MMX 指令专有的寄存器

	BP: 基址指针寄存器, 用于记录当前函数帧的开始位置, 和函数调用相关的指令会
		隐式的影响 BP 的值;
	SP: 栈寄存器, 记录当前栈指针, 和栈相关的指令会隐式的影响 SP 的值

	go 语言为了简化汇编代码的编写, 引入了 PC, FP, SP, SB 4个伪寄存器, 4个伪
	寄存器加其他的通用寄存器是 go 汇编对 cpu 的重新抽象

	在 AMD64 环境的伪寄存器:
	PC: IP 指令计数器(指令指针寄存器)寄存器--- 程序计数器?
	FP: 对应函数的帧指针, 用来访问函数的参数和返回值;
	SB: 静态基址指针, 意味静态内存的开始地址;
	SP: 栈指针对应当前函数栈帧的底部(不包括参数和返回值部分), 用于定位局部变量
	还存在一个真寄存器 SP, 对应栈顶, 用于定位调用其他函数的参数和返回值;

	真寄存器和伪寄存器的区分:
	伪寄存器需要一个标识符和偏移量为前缀, 没有标识符前缀则为真寄存器;
	如 (SP), +8(SP) 为真寄存器, a(SP), a+8(SP) 为伪寄存器


	SB 可以认为是一个和内存容量有相同大小的字节数组, 所有的静态全局符号通过 SB
	加一个偏移量定位, 而定义的符号其实就是相对于 SB 内存开始地址的偏移量, 对于
	伪寄存器 SB, 全局变量和全局函数的符号没有任何区别.

	在 go 汇编语言中, 全局变量和全局函数更为相似, 都是通过人为定义的符号来引用
	对应的内存, 由于指令和数据没有本质的差别, 因此甚至可以像操作数据那样动态
	生成指令(JIT技术的原理, TODO), 而局部变量则需要通过 SP 栈空间来隐式定义;

*/
