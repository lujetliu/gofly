package main

/*
 * 常见的并行编程有多种模型, 主要有多线程, 消息传递等; 理论上来说, 多线程和
 * 基于消息的并发编程等价, 由于多线程并发模型可自然对应到多核处理器, 主流的
 * 操作系统因此都提供了系统级的多线程支持, 因此多线程编程模型逐步被吸纳到主流
 * 的编程语言特性或语言扩展库中; 而主流编程语言对基于消息的并发编程模型支持
 * 较少, Erlang 语言是支持基于消息传递并发编程模型的代表者, 它的并发体中间不
 * 共享内存, go 语言是基于消息并发模型的集大成者, 它将基于 CSP 模型的并发编程
 * 内置到语言中, 通过一个 go 关键字就可以启动一个 Goroutine , 与 Erlang 不同,
 * go 语言的 Goroutine 之间是共享内存的.
 *
 */

/*
 * Goroutine 和系统线程
 * goroutine 是 go 特有的并发体, 是一种轻量级的线程; goroutine 和系统线程实际上
 * 只是一个量的区别, 正是这个量变引发了go语言并发编程的质的飞跃.
 *
 * 每个系统级线程都会有一个固定大小的栈(2MB), 主要保存函数递归调用时的参数和
 * 局部变量; 但固定栈的大小会存在两个问题(不够灵活):
 * - 有的线程(很多)只需要很小的栈空间, 固定的栈大小会造成浪费
 * - 少数需要巨大栈空间的线程又面临栈溢出的风险
 * 所以为了解决以上问题, 要么降低固定的栈大小, 提升空间利用率; 要么增大栈的大小
 * 以运行更深的函数递归调用, 但两者无法兼得.
 * 但一个 goroutine 会以一个很小的栈启动(2KB/4KB/8KB), 当遇到深度递归导致当前
 * 栈空间不足时, goroutine 会根据需要动态的伸缩栈的大小(主流实现中栈的最大值可
 * 达到1GB), 因为启动的代价很小, 所以可以轻易的启动很多个(成千上万)goroutine.
 * TODO: 查看 goroutine 的栈空间, 并跟踪栈空间大小的变化
 *
 *
 * TODO: 系统进程调度原理, 线程调度, goroutine 调度器
 * go 的运行时还包含了自己的调度器, 此调度器可以在n个操作系统上多工调度m个
 * goroutine.
 * 多工: 一个作业系统可以同时执行多个程式的能力.
 * go 调度器的工作原理和内核的调度相似, 但是 go 调度器只关注 go 程序中的
 * goroutine, goroutine 采用的是半抢占式的协作调度, 只有在当前 goroutine 发生
 * 阻塞时才会导致调度; 同时发生在用户态, 调度器会根据具体函数只保存必要的
 * 寄存器, 切换的代价比系统线程低的多; 运行时的一个变量 runtime.GOMAXPROCS 用
 * 于控制当前运行非阻塞 goroutine 的系统线程数.
 *
 * goroutine 相比系统线程的优点: 启动简单, 调度代价低, 极大的促进了并发编程的
 * 发展.
 *
 */

/*
 * CSP(Communication Sequential Process, 通信顺序进程)模型: TODO: 深入
 * 用于描述两个独立的的并发实体通过共享的通讯 Channel(通道) 进行通信的并发模型,
 * channel 是第一类对象(?), 不关注发送消息的实体而关注发送消息时使用的 Channel
 *
 */

/*
 *
 * 作为 go 并发编程核心的 CSP 理论的核心概念: 同步通信
 * 首先明确:
 * 并发不是并行; 并发更关注的是程序的设计层面, 并发的程序完全是可以顺序执行的,
 * 只有在真正的多核 cpu 上才可能真正的同时运行; 并行更关注的是程序的运行层面,
 * 并行一般是简单的大量重复, 例如: gpu 中对图像处理都会有大量的并行运算; 为了
 * 更好的支持并发, go 设计之初就注重在编程语言层级上设计一个简洁, 安全, 高效
 * 的抽象模型, 让程序员专注于分解问题和组合方案, 而且不用被线程管理和信号互斥
 * 这些烦琐的操作分散精力.
 *
 * 在并发编程中, 对共享资源的正确访问需要精确的控制, 在目前的绝大多数语言中,
 * 都是通过加锁等线程同步方案来解决这一困难问题, 而 go 将共享的值通过通道传递
 * (实际上多个独立执行的线程很少主动共享资源); 在任意给定的时刻, 最好只有一个
 * goroutine 能够拥有该资源; 数据竞争从设计层面上已经被杜绝; 为了提倡这种思考
 * 方式, go 的并发编程哲学:"不要通过共享内存来通信, 而应通过通信来共享内存",
 * "Do not communicate by sharing memory, instead, share memory by
 * communicating."
 * 虽然像引用计数这类简单的并发问题通过原子操作或互斥锁就能很好的实现, 但是
 * 通过通道来控制访问能使程序更加简洁正确.
 */

/*
 * 并发编程的核心概念是同步通信, 但是同步的方式有多种.
 * - 使用 sync.Mutex, 见 ./mutex.go
 * - 使用 channel, 见 ./channel.go
 */
